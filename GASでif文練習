// ... (前のコードの大部分は変更なし)

// 日付をyy/mm形式に変換する関数を修正
function formatDate(dateString) {
  // yyyy/mm/dd形式とyyyy/mm形式の両方に対応
  const parts = dateString.split('/');
  if (parts.length >= 2) {
    const year = parts[0].slice(-2);
    const month = parts[1].padStart(2, '0');
    return `${year}/${month}`;
  }
  return dateString; // 変換できない場合は元の文字列を返す
}

// ... (中略)

// 撤去予定月の処理とカウント（カテゴリーごとに初出のみカウント）
psaxRemovalData.forEach(row => {
  const hColumnValue = row[colIndexes.hColumn];
  const baColumnValue = row[colIndexes.baColumn];
  const combinationKey = `${hColumnValue}_${baColumnValue}`;
  const bzColumnValue = row[colIndexes.bzColumn];

  let category;
  let rawDate;

  if (bzColumnValue === "N件完了") {
    category = 'completed';
    rawDate = row[colIndexes.bwColumn];
  } else if (bzColumnValue === "N件予定") {
    category = 'planned';
    rawDate = row[colIndexes.bwColumn];
  } else if (bzColumnValue === "仮予定") {
    category = 'tentative';
    rawDate = row[colIndexes.bwColumn];
  } else if (bzColumnValue === "撤去自前申請") {
    category = 'selfApplied';
    rawDate = row[colIndexes.bwColumn];
  } else if (bzColumnValue === "撤去可能ビル") {
    category = 'possibleRemoval';
    rawDate = row[colIndexes.acColumn];  // AC列から日付を取得
  } else {
    return; // カテゴリーに該当しない場合はスキップ
  }

  // カテゴリーごとの重複チェック
  if (!uniqueCombinations[category].has(combinationKey)) {
    uniqueCombinations[category].add(combinationKey);

    // 日付の形式チェックと整形を修正
    if (typeof rawDate === 'string') {
      const formattedDate = formatDate(rawDate);
      if (formattedDate.match(/^\d{2}\/\d{2}$/)) {
        if (formattedDate in monthCounts[category]) {
          monthCounts[category][formattedDate]++;
        } else {
          console.log(`警告: ${formattedDate} は有効な月のリストに含まれていません。`);
        }
      } else {
        console.log(`警告: 無効な日付形式 "${rawDate}" が見つかりました。`);
      }
    } else {
      console.log(`警告: 日付が文字列ではありません: ${rawDate}`);
    }
  }
});

// ... (以下のコードは変更なし)
